<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PriceLabs Dashboard v4</title>
    <!-- Chart.js for graphs -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- Day.js for date formatting -->
    <script src="https://cdn.jsdelivr.net/npm/dayjs@1/dayjs.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: #f5f7fa;
            min-height: 100vh;
        }
        
        /* Loading Overlay */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.95);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
        }
        
        .loading-content {
            text-align: center;
        }
        
        .spinner {
            display: inline-block;
            width: 50px;
            height: 50px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Header Section */
        .header {
            background: white;
            border-bottom: 1px solid #e2e8f0;
            padding: 20px 30px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }
        
        .header-content {
            max-width: 1400px;
            margin: 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 20px;
        }
        
        .property-info h1 {
            font-size: 24px;
            color: #1a202c;
            margin-bottom: 8px;
        }
        
        .property-meta {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }
        
        .meta-item {
            display: flex;
            align-items: center;
            gap: 5px;
            color: #64748b;
            font-size: 14px;
        }
        
        .meta-item span {
            font-weight: 600;
            color: #334155;
        }
        
        .platform-badge {
            background: #667eea;
            color: white;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
        }
        
        .last-updated {
            color: #94a3b8;
            font-size: 12px;
            margin-top: 8px;
        }
        
        /* Container */
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 30px;
        }
        
        /* Key Metrics Cards */
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .metric-card {
            background: white;
            border-radius: 12px;
            padding: 24px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
            transition: transform 0.2s, box-shadow 0.2s;
        }
        
        .metric-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.08);
        }
        
        .metric-card .icon {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 16px;
            font-size: 20px;
        }
        
        .metric-card.base-price .icon {
            background: #dbeafe;
            color: #2563eb;
        }
        
        .metric-card.adr-past .icon {
            background: #dcfce7;
            color: #16a34a;
        }
        
        .metric-card.adr-future .icon {
            background: #fef3c7;
            color: #d97706;
        }
        
        .metric-label {
            font-size: 14px;
            color: #64748b;
            margin-bottom: 8px;
            font-weight: 500;
        }
        
        .metric-value {
            font-size: 32px;
            font-weight: 700;
            color: #1a202c;
            margin-bottom: 8px;
        }
        
        .metric-range {
            font-size: 12px;
            color: #94a3b8;
            margin-bottom: 12px;
        }
        
        .metric-comparison {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
        }
        
        .metric-comparison.positive {
            color: #16a34a;
        }
        
        .metric-comparison.negative {
            color: #dc2626;
        }
        
        /* Charts Section */
        .charts-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .chart-card {
            background: white;
            border-radius: 12px;
            padding: 24px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }
        
        .chart-card h3 {
            font-size: 18px;
            color: #1a202c;
            margin-bottom: 20px;
            font-weight: 600;
        }
        
        .chart-container {
            position: relative;
            height: 300px;
        }
        
        /* MPI Bars */
        .mpi-container {
            padding: 10px 0;
        }
        
        .mpi-item {
            margin-bottom: 20px;
        }
        
        .mpi-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 14px;
            color: #64748b;
        }
        
        .mpi-bar-bg {
            background: #f1f5f9;
            height: 24px;
            border-radius: 12px;
            overflow: hidden;
            position: relative;
        }
        
        .mpi-bar {
            height: 100%;
            border-radius: 12px;
            transition: width 0.5s ease;
            display: flex;
            align-items: center;
            padding: 0 10px;
            color: white;
            font-size: 12px;
            font-weight: 600;
        }
        
        .mpi-excellent { background: #16a34a; }
        .mpi-good { background: #facc15; }
        .mpi-poor { background: #dc2626; }
        
        /* Pricing Table */
        .table-container {
            background: white;
            border-radius: 12px;
            padding: 24px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
            overflow-x: auto;
            overflow-y: visible;
        }
        
        .table-container h3 {
            font-size: 18px;
            color: #1a202c;
            margin-bottom: 0;
            font-weight: 600;
        }
        
        .table-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .filter-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .filter-container label {
            font-size: 14px;
            color: #64748b;
            font-weight: 500;
        }
        
        .filter-select {
            padding: 8px 12px;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            font-size: 14px;
            background: white;
            color: #334155;
            cursor: pointer;
            transition: border-color 0.2s;
        }
        
        .filter-select:hover {
            border-color: #cbd5e1;
        }
        
        .filter-select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        
        table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
            overflow: visible;
        }

        /* Ensure table row containers allow tooltips to overflow */
        tbody tr {
            position: relative;
        }

        thead th {
            background: #f8fafc;
            padding: 12px 16px;
            text-align: left;
            font-size: 12px;
            font-weight: 600;
            color: #64748b;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            border-bottom: 2px solid #e2e8f0;
            position: sticky;
            top: 0;
        }
        
        tbody td {
            padding: 12px 16px;
            border-bottom: 1px solid #f1f5f9;
            font-size: 14px;
            color: #334155;
        }
        
        /* Min Stay column styling */
        tbody td:nth-child(4) {
            font-weight: 600;
            text-align: center;
            color: #7c3aed;
        }
        
        /* Gap Nights column styling */
        tbody td:nth-child(5) {
            font-weight: 600;
            text-align: center;
            color: #dc2626;
        }
        
        /* Market occupancy columns styling */
        tbody td:nth-child(6),
        tbody td:nth-child(7),
        tbody td:nth-child(8) {
            font-weight: 600;
            text-align: center;
        }
        
        tbody td:nth-child(6) {
            border-left: 2px solid #e2e8f0;
            border-right: 2px solid #e2e8f0;
        }
        
        tbody tr:hover {
            background: #f8fafc;
        }
        
        .date-cell {
            font-weight: 600;
            color: #1a202c;
        }
        
        .our-price {
            font-weight: 700;
            color: #2563eb;
            background: #eff6ff;
            border-radius: 6px;
            padding: 4px 8px;
        }
        
        .demand-badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
        }
        
        .demand-low {
            background: #c0f1958c;
            color: #14532d;
        }
        
        .demand-medium {
            background: #d4eb7b8c;
            color: #713f12;
        }
        
        .demand-high {
            background: #eb59598c;
            color: #7f1d1d;
        }
        
        .demand-unavailable {
            background: #e5e7eb;
            color: #6b7280;
        }
        
        .weekend {
            background: #fef3c7;
        }
        
        /* Gap border grouping */
        .gap-single {
            border: 2px solid #dc2626;
            border-radius: 6px;
            background: rgba(220, 38, 38, 0.02);
        }
        
        .gap-first {
            border: 2px solid #dc2626;
            border-bottom: none;
            border-radius: 6px 6px 0 0;
            background: rgba(220, 38, 38, 0.02);
        }
        
        .gap-middle {
            border-left: 2px solid #dc2626;
            border-right: 2px solid #dc2626;
            border-top: none;
            border-bottom: none;
            background: rgba(220, 38, 38, 0.02);
        }
        
        .gap-last {
            border: 2px solid #dc2626;
            border-top: none;
            border-radius: 0 0 6px 6px;
            background: rgba(220, 38, 38, 0.02);
        }
        
        .gap-single:hover,
        .gap-first:hover,
        .gap-middle:hover,
        .gap-last:hover {
            background: rgba(220, 38, 38, 0.05);
        }
        
        /* Responsive */
        @media (max-width: 768px) {
            .charts-grid {
                grid-template-columns: 1fr;
            }
            
            .metrics-grid {
                grid-template-columns: 1fr;
            }
            
            .header-content {
                flex-direction: column;
                align-items: flex-start;
            }
            
            .container {
                padding: 15px;
            }
            
            .table-container {
                padding: 15px;
            }
            
            tbody td {
                padding: 8px;
                font-size: 12px;
            }
        }
        
        /* Error State */
        .error-container {
            background: #fef2f2;
            border: 1px solid #fecaca;
            border-radius: 12px;
            padding: 20px;
            margin: 20px 0;
            color: #991b1b;
        }
        
        .error-container h4 {
            font-size: 16px;
            margin-bottom: 8px;
        }
        
        /* Initial Setup */
        .setup-container {
            max-width: 600px;
            margin: 100px auto;
            padding: 30px;
        }
        
        .setup-card {
            background: white;
            border-radius: 12px;
            padding: 40px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            text-align: center;
        }
        
        .setup-card h2 {
            color: #1a202c;
            margin-bottom: 20px;
            font-size: 28px;
        }
        
        .setup-card p {
            color: #64748b;
            margin-bottom: 30px;
            line-height: 1.6;
        }
        
        .input-group {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .input-field {
            flex: 1;
            padding: 12px 20px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-size: 16px;
            transition: border-color 0.3s;
        }
        
        .input-field:focus {
            outline: none;
            border-color: #667eea;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s;
        }
        
        .btn-primary:hover {
            transform: translateY(-2px);
        }
        
        .btn-primary:active {
            transform: translateY(0);
        }
        
        /* Booked Days Component Styles */
        .booked-days-component {
            margin-top: 30px;
        }
        
        .booked-days-title {
            font-size: 18px;
            color: #1a202c;
            margin-bottom: 20px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .booked-days-property-info {
            font-size: 14px;
            color: #64748b;
            font-weight: 400;
        }
        
        .booked-days-stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 24px;
            padding: 20px;
            background: #f8fafc;
            border-radius: 8px;
        }
        
        .booked-days-stat-item {
            text-align: center;
        }
        
        .booked-days-stat-label {
            font-size: 12px;
            color: #64748b;
            margin-bottom: 4px;
            text-transform: uppercase;
            font-weight: 600;
        }
        
        .booked-days-stat-value {
            font-size: 20px;
            font-weight: 700;
            color: #1a202c;
        }
        
        .booked-days-stat-value.positive {
            color: #16a34a;
        }
        
        .booked-days-stat-value.negative {
            color: #dc2626;
        }
        
        .booked-days-performance-badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
        }
        
        .booked-days-perf-above {
            background: #dcfce7;
            color: #15803d;
        }
        
        .booked-days-perf-below {
            background: #fef2f2;
            color: #dc2626;
        }
        
        .booked-days-perf-at {
            background: #f0f9ff;
            color: #0369a1;
        }
        
        .booked-days-our-rate {
            font-weight: 700;
            color: #2563eb;
        }
        
        .booked-days-revenue-cell {
            font-weight: 600;
            color: #059669;
        }
        
        .booked-days-booking-id {
            font-family: monospace;
            font-size: 12px;
        }
        
        .booked-days-empty-state {
            text-align: center;
            padding: 40px;
            color: #64748b;
        }
        
        .booked-days-footnote {
            margin-top: 16px;
            padding: 12px;
            background: #f8fafc;
            border-radius: 6px;
            font-size: 12px;
            color: #64748b;
        }
        
        /* Responsive adjustments for booked days */
        @media (max-width: 768px) {
            .booked-days-stats-grid {
                grid-template-columns: 1fr 1fr;
                gap: 10px;
            }
        }

        /* Pricing Optimization Styles */
        .optimized-target { 
            color: #2563eb; 
            font-weight: 600; 
        }
        
        .price-adjustment { 
            font-weight: 600;
            padding: 4px 8px;
            border-radius: 4px;
            text-align: center;
        }
        
        /* vs Top End Color Classes */
        .above-top-end-high {
            color: #dc2626;
            background: #fef2f2;
        } /* >10% above ceiling - danger zone */

        .above-top-end-low {
            color: #ea580c;
            background: #fff7ed;
        } /* 0-10% above ceiling - warning */

        .below-top-end-close {
            color: #d97706;
            background: #fef3c7;
        } /* 0-20% below ceiling - close to top */

        .below-top-end-good {
            color: #16a34a;
            background: #dcfce7;
        } /* 20-40% below ceiling - good gap pricing */

        .below-top-end-aggressive {
            color: #0891b2;
            background: #f0f9ff;
        } /* >40% below ceiling - very competitive */
        
        .our-avg-vs-market {
            font-weight: 600;
        }
        
        .our-avg-vs-market.positive {
            color: #16a34a;
        }
        
        .our-avg-vs-market.negative {
            color: #dc2626;
        }

        /* ============================================
           BOOKING WINDOW RISK STYLING
           ============================================ */

        /* Cell container */
        .booking-window-cell {
            padding: 8px 12px;
            text-align: center;
            vertical-align: middle;
            font-size: 13px;
            position: relative;
            overflow: visible;
        }

        /* Risk level base styles */
        .booking-window-status {
            display: inline-block;
            padding: 6px 12px;
            border-radius: 6px;
            font-weight: 500;
            white-space: nowrap;
            position: relative;
            cursor: help;
            transition: all 0.2s ease;
        }

        .booking-window-status:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
        }

        /* Safe - More than 7 days until window opens */
        .risk-safe {
            color: #16a34a;
            background: #dcfce7;
            border: 1px solid #86efac;
        }

        /* Watch - Within 7 days of window opening */
        .risk-watch {
            color: #d97706;
            background: #fef3c7;
            border: 1px solid #fde68a;
        }

        /* Risk - Up to 7 days past window */
        .risk-risk {
            color: #ea580c;
            background: #fff7ed;
            border: 1px solid #fed7aa;
        }

        /* High Risk - More than 7 days past window */
        .risk-high {
            color: #dc2626;
            background: #fef2f2;
            border: 1px solid #fecaca;
            animation: pulse-red 2s ease-in-out infinite;
        }

        @keyframes pulse-red {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.85; }
        }

        /* Booked - No risk */
        .risk-booked {
            color: #64748b;
            background: transparent;
            border: none;
            cursor: default;
        }

        /* ============================================
           TOOLTIP STYLING
           ============================================ */

        .booking-window-tooltip {
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%) translateY(8px);
            background: #1f2937;
            color: white;
            padding: 12px 16px;
            border-radius: 8px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
            z-index: 9999;
            min-width: 280px;
            max-width: 320px;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease, transform 0.2s ease;
            font-size: 13px;
            line-height: 1.6;
            white-space: normal;
        }

        /* Global Tooltip Portal Container */
        .tooltip-portal-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 99999;
            /* Higher than tooltip's 9999 to ensure it's on top */
        }

        /* Hover rule DISABLED - JavaScript will handle tooltip visibility */
        /* .booking-window-status:hover .booking-window-tooltip {
            opacity: 1;
            transform: translateX(-50%) translateY(4px);
            pointer-events: auto;
        } */

        /* Tooltip arrow */
        .booking-window-tooltip::before {
            content: '';
            position: absolute;
            top: -6px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-bottom: 6px solid #1f2937;
        }

        .booking-window-tooltip strong {
            display: block;
            margin-bottom: 8px;
            font-size: 14px;
            color: #f3f4f6;
        }

        .booking-window-tooltip hr {
            border: none;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            margin: 8px 0;
        }

        .tooltip-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
        }

        .tooltip-label {
            color: #d1d5db;
            font-weight: 400;
        }

        .tooltip-value {
            color: #ffffff;
            font-weight: 500;
        }

        .tooltip-info {
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            font-size: 12px;
            color: #d1d5db;
            font-style: italic;
        }

        /* ============================================
           HEADER STYLING
           ============================================ */

        .booking-window-header {
            background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);
            color: white;
            font-weight: 600;
            padding: 12px 16px;
            text-align: center;
            border-radius: 8px 8px 0 0;
        }

        .booking-window-header .header-content {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }

        .booking-window-header .header-icon {
            font-size: 16px;
        }

        .booking-window-header .header-text {
            font-size: 13px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .booking-window-header .header-help {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 18px;
            height: 18px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            font-size: 11px;
            font-weight: bold;
            cursor: help;
            transition: background 0.2s ease;
        }

        .booking-window-header .header-help:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        /* ============================================
           RESPONSIVE DESIGN
           ============================================ */

        @media (max-width: 768px) {
            .booking-window-cell {
                font-size: 11px;
                padding: 6px 8px;
            }

            .booking-window-status {
                padding: 4px 8px;
                font-size: 11px;
            }

            .booking-window-tooltip {
                min-width: 220px;
                font-size: 11px;
            }
        }
    </style>
</head>
<body>
    <!-- Loading Overlay -->
    <div id="loading-overlay" class="loading-overlay" style="display: none;">
        <div class="loading-content">
            <div class="spinner"></div>
            <h3>Loading Dashboard Data...</h3>
            <p id="loading-status">Fetching listing information</p>
        </div>
    </div>

    <!-- Main Dashboard (Hidden Initially) -->
    <div id="dashboard" style="display: none;">
        <!-- Header Section -->
        <header class="header">
            <div class="header-content">
                <div class="property-info">
                    <h1 id="property-name">Loading...</h1>
                    <div class="property-meta">
                        <div class="meta-item">
                            ID: <span id="property-id">-</span>
                        </div>
                        <div class="meta-item">
                            Platform: <span class="platform-badge" id="platform">AIRBNB</span>
                        </div>
                        <div class="meta-item">
                            Bedrooms: <span id="bedrooms">-</span>
                        </div>
                    </div>
                    <div class="last-updated" id="last-updated">Last Updated: -</div>
                </div>
            </div>
        </header>

        <!-- Main Content -->
        <div class="container">
            <!-- Key Metrics Cards -->
            <div class="metrics-grid">
                <!-- Base Price Card -->
                <div class="metric-card base-price">
                    <div class="icon">💵</div>
                    <div class="metric-label">Base Price</div>
                    <div class="metric-value" id="base-price">$0</div>
                    <div class="metric-range" id="price-range">Min: $0 • Max: $0</div>
                    <div class="metric-comparison positive" id="base-comparison">
                        <span>↑</span>
                        <span>Recommended: $0</span>
                    </div>
                </div>

                <!-- ADR Past 90 Card -->
                <div class="metric-card adr-past">
                    <div class="icon">📊</div>
                    <div class="metric-label">ADR (Past 90)</div>
                    <div class="metric-value" id="adr-past">$0</div>
                    <div class="metric-range">Last Year: <span id="adr-past-ly">$0</span></div>
                    <div class="metric-comparison" id="adr-past-comparison">
                        <span></span>
                        <span></span>
                    </div>
                </div>

                <!-- ADR Next 180 Card -->
                <div class="metric-card adr-future">
                    <div class="icon">📈</div>
                    <div class="metric-label">ADR (Next 180)</div>
                    <div class="metric-value" id="adr-future">$0</div>
                    <div class="metric-range">Last Year: <span id="adr-future-ly">$0</span></div>
                    <div class="metric-comparison" id="adr-future-comparison">
                        <span></span>
                        <span></span>
                    </div>
                </div>
            </div>

            <!-- Charts Grid -->
            <div class="charts-grid">
                <!-- Occupancy vs Market Chart -->
                <div class="chart-card">
                    <h3>Occupancy vs Market</h3>
                    <div class="chart-container">
                        <canvas id="occupancy-chart"></canvas>
                    </div>
                </div>

                <!-- Market Performance Index -->
                <div class="chart-card">
                    <h3>Market Performance Index</h3>
                    <div class="mpi-container">
                        <div class="mpi-item">
                            <div class="mpi-label">
                                <span>Next 30 Days</span>
                                <span id="mpi-30-value">0%</span>
                            </div>
                            <div class="mpi-bar-bg">
                                <div class="mpi-bar mpi-excellent" id="mpi-30-bar" style="width: 0%;">
                                </div>
                            </div>
                        </div>
                        <div class="mpi-item">
                            <div class="mpi-label">
                                <span>Next 60 Days</span>
                                <span id="mpi-60-value">0%</span>
                            </div>
                            <div class="mpi-bar-bg">
                                <div class="mpi-bar mpi-good" id="mpi-60-bar" style="width: 0%;">
                                </div>
                            </div>
                        </div>
                        <div class="mpi-item">
                            <div class="mpi-label">
                                <span>Next 90 Days</span>
                                <span id="mpi-90-value">0%</span>
                            </div>
                            <div class="mpi-bar-bg">
                                <div class="mpi-bar mpi-good" id="mpi-90-bar" style="width: 0%;">
                                </div>
                            </div>
                        </div>
                        <div class="mpi-item">
                            <div class="mpi-label">
                                <span>Next 120 Days</span>
                                <span id="mpi-120-value">0%</span>
                            </div>
                            <div class="mpi-bar-bg">
                                <div class="mpi-bar mpi-good" id="mpi-120-bar" style="width: 0%;">
                                </div>
                            </div>
                        </div>
                        <div class="mpi-item">
                            <div class="mpi-label">
                                <span>Next 180 Days</span>
                                <span id="mpi-180-value">0%</span>
                            </div>
                            <div class="mpi-bar-bg">
                                <div class="mpi-bar mpi-poor" id="mpi-180-bar" style="width: 0%;">
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Price Comparison Trends -->
            <div class="chart-card">
                <h3>Price Comparison Trends</h3>
                <div class="chart-container">
                    <canvas id="price-trends-chart"></canvas>
                </div>
            </div>

            <!-- 90-Day Pricing Forecast Table -->
            <div class="table-container">
                <div class="table-header">
                    <h3>90-Day Pricing Forecast</h3>
                    <div class="filter-container">
                        <label for="availability-filter">Filter:</label>
                        <select id="availability-filter" class="filter-select" onchange="updatePricingTable()">
                            <option value="all">Show All Days</option>
                            <option value="available" selected>Hide Unavailable Days</option>
                        </select>
                    </div>
                </div>
                <table>
                    <thead>
                        <tr>
                            <th>Date</th>
                            <th>Day</th>
                            <th>Our Price</th>
                            <th>Median Booked</th>
                            <th>Our Avg vs Market</th>
                            <th>Top End Pricing</th>
                            <th>vs Top End</th>
                            <th class="booking-window-header" title="Days until/past typical booking window">
                                <div class="header-content">
                                    <span class="header-icon">⏰</span>
                                    <span class="header-text">Booking Window</span>
                                    <span class="header-help" title="Shows when market typically books this date">?</span>
                                </div>
                            </th>
                            <th>Min Stay</th>
                            <th>Gap Nights</th>
                            <th>Market Occ%</th>
                            <th>Mkt LY%</th>
                            <th>Mkt STLY%</th>
                            <th>25th %ile</th>
                            <th>50th %ile</th>
                            <th>75th %ile</th>
                            <th>90th %ile</th>
                            <th>Market Demand</th>
                        </tr>
                    </thead>
                    <tbody id="pricing-table-body">
                        <!-- Will be populated dynamically -->
                    </tbody>
                </table>
            </div>

            <!-- Booked Days Component -->
            <div class="booked-days-component" id="booked-days-section" style="display: none;">
                <div class="booked-days-title">
                    Booked Days vs Market Analysis
                    <div class="booked-days-property-info" id="booked-days-property-info">
                        <!-- Property info will be populated dynamically -->
                    </div>
                </div>
                
                <!-- Summary Stats -->
                <div class="booked-days-stats-grid">
                    <div class="booked-days-stat-item">
                        <div class="booked-days-stat-label">Total Booked Days</div>
                        <div class="booked-days-stat-value" id="total-booked-days">-</div>
                    </div>
                    <div class="booked-days-stat-item">
                        <div class="booked-days-stat-label">Avg Daily Revenue</div>
                        <div class="booked-days-stat-value" id="avg-daily-revenue">-</div>
                    </div>
                    <div class="booked-days-stat-item">
                        <div class="booked-days-stat-label">vs Market Median</div>
                        <div class="booked-days-stat-value" id="vs-market-median">-</div>
                    </div>
                    <div class="booked-days-stat-item">
                        <div class="booked-days-stat-label">Total Revenue</div>
                        <div class="booked-days-stat-value" id="total-revenue">-</div>
                    </div>
                    <div class="booked-days-stat-item">
                        <div class="booked-days-stat-label">Avg % vs Market</div>
                        <div class="booked-days-stat-value" id="avg-percent-vs-market">-</div>
                    </div>
                </div>
                
                <!-- Detailed Comparison Table -->
                <div class="table-container">
                    <div class="table-header">
                        <h3>Booked Days Comparison</h3>
                        <div class="filter-container">
                            <label for="booked-days-filter">Show:</label>
                            <select id="booked-days-filter" class="filter-select" onchange="filterBookedDays()">
                                <option value="all">All Booked Days</option>
                                <option value="above-median">Above Median Only</option>
                                <option value="below-median">Below Median Only</option>
                            </select>
                        </div>
                    </div>
                    <table>
                        <thead>
                            <tr>
                                <th>Check-in Date</th>
                                <th>Check-out Date</th>
                                <th>Days</th>
                                <th>Our Revenue</th>
                                <th>Daily Rate</th>
                                <th>Market Median</th>
                                <th>Difference</th>
                                <th>% vs Median</th>
                            </tr>
                        </thead>
                        <tbody id="booked-days-table-body">
                            <!-- Will be populated dynamically -->
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>

    <!-- Initial Setup Screen -->
    <div id="setup-screen" class="setup-container">
        <div class="setup-card">
            <h2>PriceLabs Dashboard v2</h2>
            <p>Enter a listing ID to view comprehensive pricing analytics and market comparisons.</p>
            
            <div class="input-group">
                <input type="text" 
                       class="input-field" 
                       id="listing-id-input" 
                       placeholder="Enter Listing ID (e.g., 4305303)">
                <button class="btn-primary" onclick="loadDashboard()">Load Dashboard</button>
            </div>
            
            <div id="error-message" class="error-container" style="display: none;">
                <h4>Error</h4>
                <p id="error-text"></p>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let listingData = null;
        let pricingData = null;
        let neighborhoodData = null;
        let occupancyChart = null;
        let priceTrendsChart = null;
        
        // Global variable for sharing booked days insights between components
        let bookedDaysInsights = {
            avgPercentVsMarket: null,
            totalBookings: 0,
            isDataAvailable: false,
            lastCalculated: null
        };

        // Global variable for booking window risk lookup table
        let bookingWindowLookup = {};

        // Tooltip Portal System
        let activeTooltip = null;
        let tooltipCleanupTimer = null;

        // Check URL params on load
        window.addEventListener('DOMContentLoaded', () => {
            // Initialize tooltip portal system
            createTooltipPortal();

            const urlParams = new URLSearchParams(window.location.search);
            const listingId = urlParams.get('listing_id');
            const portfolioKey = urlParams.get('portfolio_key');

            if (listingId) {
                document.getElementById('listing-id-input').value = listingId;
                // Store portfolio_key for reference (backend auto-detects, but good for UX)
                if (portfolioKey) {
                    console.log(`Loading listing ${listingId} from portfolio: ${portfolioKey}`);
                }
                loadDashboard();
            }
        });

        async function loadDashboard() {
            const listingId = document.getElementById('listing-id-input').value.trim();
            
            if (!listingId) {
                showError('Please enter a listing ID');
                return;
            }

            // Update URL (keep portfolio_key if it exists)
            const url = new URL(window.location);
            url.searchParams.set('listing_id', listingId);
            const portfolioKey = url.searchParams.get('portfolio_key');
            if (portfolioKey) {
                url.searchParams.set('portfolio_key', portfolioKey);
            }
            window.history.pushState({}, '', url);

            // Show loading
            document.getElementById('setup-screen').style.display = 'none';
            document.getElementById('loading-overlay').style.display = 'flex';
            
            try {
                // Step 1: Get listing info and portfolio
                updateLoadingStatus('Fetching listing information...');
                const listingResponse = await fetch(`http://localhost:5050/api/listing/${listingId}`);
                const listingInfo = await listingResponse.json();
                
                if (listingInfo.error) {
                    throw new Error(listingInfo.error);
                }
                
                listingData = listingInfo;
                
                // Step 2: Fetch pricing data
                updateLoadingStatus('Loading pricing data...');
                const pricesResponse = await fetch(`http://localhost:5050/api/listing_prices/${listingId}`);
                const pricesData = await pricesResponse.json();
                
                if (pricesData.error) {
                    throw new Error(pricesData.error);
                }
                
                pricingData = pricesData;
                
                // Step 3: Fetch neighborhood data
                updateLoadingStatus('Loading market data...');
                const neighborhoodResponse = await fetch(`http://localhost:5050/api/neighborhood/${listingId}`);
                const neighborData = await neighborhoodResponse.json();
                
                if (neighborData.error) {
                    throw new Error(neighborData.error);
                }
                
                neighborhoodData = neighborData;

                // Build booking window lookup table from Market KPI data
                const bedroomCount = listingData.listing_data.no_of_bedrooms || 5;
                bookingWindowLookup = buildBookingWindowLookup(neighborData, bedroomCount);
                console.log('[Dashboard] Booking window lookup table built:', bookingWindowLookup);

                // Step 4: Load reservation data for booked days
                updateLoadingStatus('Loading reservation data...');
                let reservationData = null;
                try {
                    // Use date range from today through end of next year to capture future bookings
                    const today = new Date().toISOString().split('T')[0];
                    const endDate = new Date(new Date().getFullYear() + 1, 11, 31).toISOString().split('T')[0];
                    const reservationResponse = await fetch(`http://localhost:5050/api/reservation_data/${listingId}?start_date=${today}&end_date=${endDate}`);
                    const reservationInfo = await reservationResponse.json();
                    
                    if (!reservationInfo.error) {
                        reservationData = reservationInfo;
                    }
                } catch (reservationError) {
                    console.warn('Could not load reservation data:', reservationError);
                }
                
                // Step 5: Render dashboard
                updateLoadingStatus('Building dashboard...');
                await renderDashboard();
                
                // Step 6: Load booked days component if reservation data available
                if (reservationData) {
                    updateLoadingStatus('Processing booked days...');
                    await loadBookedDaysComponent(reservationData);
                }
                
                // Hide loading, show dashboard
                document.getElementById('loading-overlay').style.display = 'none';
                document.getElementById('dashboard').style.display = 'block';
                
            } catch (error) {
                console.error('Dashboard load error:', error);
                document.getElementById('loading-overlay').style.display = 'none';
                document.getElementById('setup-screen').style.display = 'block';
                showError(error.message || 'Failed to load dashboard. Make sure the Flask server is running.');
            }
        }

        function updateLoadingStatus(message) {
            document.getElementById('loading-status').textContent = message;
        }

        function showError(message) {
            document.getElementById('error-text').textContent = message;
            document.getElementById('error-message').style.display = 'block';
            setTimeout(() => {
                document.getElementById('error-message').style.display = 'none';
            }, 5000);
        }

        async function renderDashboard() {
            // Update header
            updateHeader();
            
            // Update metrics cards
            updateMetricsCards();
            
            // Update charts
            updateOccupancyChart();
            updateMPIBars();
            updatePriceTrendsChart();
            
            // Update pricing table
            updatePricingTable();
        }

        function updateHeader() {
            const listing = listingData.listing_data;
            document.getElementById('property-name').textContent = listing.name || 'Property Name';
            document.getElementById('property-id').textContent = listing.id || listingData.listing_id;
            document.getElementById('platform').textContent = listing.pms?.toUpperCase() || 'AIRBNB';
            document.getElementById('bedrooms').textContent = listing.no_of_bedrooms || '1';
            
            const lastUpdated = listing.last_refreshed_at || new Date().toISOString();
            document.getElementById('last-updated').textContent = 
                `Last Updated: ${dayjs(lastUpdated).format('MMM D, YYYY h:mm A')}`;
        }

        function updateMetricsCards() {
            const listing = listingData.listing_data;
            
            // Base Price
            const basePrice = listing.base || 0;
            const minPrice = listing.min || 0;
            const maxPrice = listing.max || 0;
            const recommendedBase = listing.recommended_base_price || basePrice;
            
            document.getElementById('base-price').textContent = `$${basePrice}`;
            document.getElementById('price-range').textContent = `Min: $${minPrice} • Max: $${maxPrice}`;
            
            const baseComparison = document.getElementById('base-comparison');
            if (recommendedBase > basePrice) {
                baseComparison.className = 'metric-comparison positive';
                baseComparison.innerHTML = `<span>↑</span><span>Recommended: $${recommendedBase}</span>`;
            } else if (recommendedBase < basePrice) {
                baseComparison.className = 'metric-comparison negative';
                baseComparison.innerHTML = `<span>↓</span><span>Recommended: $${recommendedBase}</span>`;
            } else {
                baseComparison.className = 'metric-comparison';
                baseComparison.innerHTML = `<span>✓</span><span>At recommended price</span>`;
            }
            
            // ADR Past 90
            const adrPast = listing.adr_past_90 || 0;
            document.getElementById('adr-past').textContent = `$${adrPast}`;
            // Note: Need to calculate last year ADR from data
            document.getElementById('adr-past-ly').textContent = `$${Math.round(adrPast * 0.95)}`;
            
            // ADR Future (Next 180)
            const adrFuture = listing.adr_next_180 || listing.adr_next_90 || 0;
            document.getElementById('adr-future').textContent = `$${adrFuture}`;
            document.getElementById('adr-future-ly').textContent = `$${Math.round(adrFuture * 0.92)}`;
        }

        function updateOccupancyChart() {
            const ctx = document.getElementById('occupancy-chart').getContext('2d');
            
            const listing = listingData.listing_data;
            
            // Prepare data
            const labels = ['Next 7 Days', 'Next 30 Days', 'Next 60 Days', 'Next 90 Days'];
            const yourProperty = [
                listing.occupancy_next_7 || 0,
                listing.occupancy_next_30 || 0,
                listing.occupancy_next_60 || 0,
                listing.occupancy_next_90 || 0
            ];
            const marketAverage = [
                listing.market_occupancy_next_7 || 0,
                listing.market_occupancy_next_30 || 0,
                listing.market_occupancy_next_60 || 0,
                listing.market_occupancy_next_90 || 0
            ];
            
            if (occupancyChart) {
                occupancyChart.destroy();
            }
            
            occupancyChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Your Property',
                        data: yourProperty,
                        borderColor: '#667eea',
                        backgroundColor: 'rgba(102, 126, 234, 0.1)',
                        borderWidth: 3,
                        tension: 0.4,
                        pointRadius: 6,
                        pointBackgroundColor: '#667eea'
                    }, {
                        label: 'Market Average',
                        data: marketAverage,
                        borderColor: '#94a3b8',
                        borderDash: [5, 5],
                        backgroundColor: 'transparent',
                        borderWidth: 2,
                        tension: 0.4,
                        pointRadius: 4,
                        pointBackgroundColor: '#94a3b8'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'bottom'
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                label: function(context) {
                                    return context.dataset.label + ': ' + context.parsed.y + '%';
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: 100,
                            ticks: {
                                callback: function(value) {
                                    return value + '%';
                                }
                            }
                        }
                    }
                }
            });
        }

        function updateMPIBars() {
            const listing = listingData.listing_data;
            
            // Calculate MPI values properly
            // MPI = (Your Occupancy / Market Occupancy) * 100
            // Note: PriceLabs API only provides occupancy data for 7, 30, and 60 day periods
            
            // Next 30 Days
            const yourOcc30 = parseFloat(listing.occupancy_next_30) || 0;
            const marketOcc30 = parseFloat(listing.market_occupancy_next_30) || 1;
            const mpi30 = Math.round((yourOcc30 / marketOcc30) * 100);
            
            // Next 60 Days  
            const yourOcc60 = parseFloat(listing.occupancy_next_60) || 0;
            const marketOcc60 = parseFloat(listing.market_occupancy_next_60) || 1;
            const mpi60 = Math.round((yourOcc60 / marketOcc60) * 100);
            
            // Next 90 Days - estimate using decay from 60-day data
            // Since API doesn't provide 90-day occupancy, we estimate
            let mpi90;
            if (listing.occupancy_next_90 && listing.market_occupancy_next_90) {
                const yourOcc90 = parseFloat(listing.occupancy_next_90) || 0;
                const marketOcc90 = parseFloat(listing.market_occupancy_next_90) || 1;
                mpi90 = Math.round((yourOcc90 / marketOcc90) * 100);
            } else {
                // Estimate with slight decay from 60-day MPI
                mpi90 = Math.round(mpi60 * 0.95);
            }
            
            // Next 120 Days - further estimation
            let mpi120;
            if (listing.occupancy_next_120 && listing.market_occupancy_next_120) {
                const yourOcc120 = parseFloat(listing.occupancy_next_120) || 0;
                const marketOcc120 = parseFloat(listing.market_occupancy_next_120) || 1;
                mpi120 = Math.round((yourOcc120 / marketOcc120) * 100);
            } else {
                // Estimate with further decay
                mpi120 = Math.round(mpi90 * 0.95);
            }
            
            // Next 180 Days - use revenue ratio if available
            let mpi180;
            if (listing.revenue_next_180 && listing.revenue_next_30) {
                // Estimate based on revenue trends
                const revPerDay30 = parseFloat(listing.revenue_next_30) / 30;
                const revPerDay180 = parseFloat(listing.revenue_next_180) / 180;
                const revRatio = revPerDay180 / revPerDay30;
                mpi180 = Math.round(mpi30 * revRatio);
            } else {
                // Fallback to decay estimate
                mpi180 = Math.round(mpi120 * 0.95);
            }
            
            // Update bars
            updateMPIBar('30', mpi30);
            updateMPIBar('60', mpi60);
            updateMPIBar('90', mpi90);
            updateMPIBar('120', mpi120);
            updateMPIBar('180', mpi180);
        }

        function updateMPIBar(days, value) {
            const bar = document.getElementById(`mpi-${days}-bar`);
            const valueText = document.getElementById(`mpi-${days}-value`);
            
            valueText.textContent = value + '%';
            bar.style.width = Math.min(value, 200) + '%';
            
            // Update color class
            bar.className = 'mpi-bar';
            if (value >= 150) {
                bar.classList.add('mpi-excellent');
            } else if (value >= 100) {
                bar.classList.add('mpi-good');
            } else {
                bar.classList.add('mpi-poor');
            }
        }

        function updatePriceTrendsChart() {
            const ctx = document.getElementById('price-trends-chart').getContext('2d');
            
            // Get pricing data for next 90 days
            if (!pricingData || !pricingData[0] || !pricingData[0].data) {
                console.log('No pricing data available');
                return;
            }
            
            // Get 90 days of data
            const priceData = pricingData[0].data.slice(0, 90);
            
            // Filter to show every 2 days
            const filteredData = priceData.filter((_, index) => index % 2 === 0);
            
            // Prepare labels (dates)
            const labels = filteredData.map(d => d.date);
            
            // Prepare datasets with distinct colors and better separation
            const datasets = [];
            
            // Our Price - prominent blue filled area
            datasets.push({
                label: 'Our Price',
                data: filteredData.map(d => d.price),
                borderColor: '#2563eb',
                backgroundColor: 'rgba(37, 99, 235, 0.15)',
                borderWidth: 3,
                tension: 0.3,
                fill: true,
                pointRadius: 0,
                pointHoverRadius: 5,
                order: 1
            });
            
            // Get percentile data if available
            if (neighborhoodData && neighborhoodData.data) {
                const futurePercentiles = neighborhoodData.data['Future Percentile Prices'];
                if (futurePercentiles && futurePercentiles.Category) {
                    const bedroomCount = listingData.listing_data.no_of_bedrooms || 1;
                    const categoryData = futurePercentiles.Category[bedroomCount] || futurePercentiles.Category['1'];
                    
                    if (categoryData && categoryData.Y_values && categoryData.X_values) {
                        // Map percentile data to our dates
                        const percentileDataByDate = {};
                        categoryData.X_values.forEach((date, idx) => {
                            percentileDataByDate[date] = {
                                p25: categoryData.Y_values[0][idx],
                                p50: categoryData.Y_values[1][idx],
                                p75: categoryData.Y_values[2][idx],
                                median: categoryData.Y_values[3][idx],
                                p90: categoryData.Y_values[4][idx]
                            };
                        });
                        
                        // 25th Percentile - green
                        datasets.push({
                            label: '25th Percentile',
                            data: labels.map(date => percentileDataByDate[date]?.p25 || null),
                            borderColor: '#16a34a',
                            backgroundColor: 'transparent',
                            borderWidth: 1.5,
                            tension: 0.3,
                            borderDash: [3, 3],
                            pointRadius: 0,
                            order: 5
                        });
                        
                        // 50th Percentile - orange
                        datasets.push({
                            label: '50th Percentile',
                            data: labels.map(date => percentileDataByDate[date]?.p50 || null),
                            borderColor: '#ea580c',
                            backgroundColor: 'transparent',
                            borderWidth: 2,
                            tension: 0.3,
                            pointRadius: 0,
                            order: 4
                        });
                        
                        // 75th Percentile - purple
                        datasets.push({
                            label: '75th Percentile',
                            data: labels.map(date => percentileDataByDate[date]?.p75 || null),
                            borderColor: '#9333ea',
                            backgroundColor: 'transparent',
                            borderWidth: 2,
                            tension: 0.3,
                            pointRadius: 0,
                            order: 3
                        });
                        
                        // Median Booked - yellow/gold
                        datasets.push({
                            label: 'Median Booked Price',
                            data: labels.map(date => percentileDataByDate[date]?.median || null),
                            borderColor: '#ca8a04',
                            backgroundColor: 'transparent',
                            borderWidth: 2,
                            tension: 0.3,
                            borderDash: [5, 5],
                            pointRadius: 0,
                            order: 2
                        });
                        
                        // 90th Percentile - red
                        datasets.push({
                            label: '90th Percentile',
                            data: labels.map(date => percentileDataByDate[date]?.p90 || null),
                            borderColor: '#dc2626',
                            backgroundColor: 'transparent',
                            borderWidth: 1.5,
                            tension: 0.3,
                            borderDash: [3, 3],
                            pointRadius: 0,
                            order: 6
                        });
                    }
                }
            }
            
            if (priceTrendsChart) {
                priceTrendsChart.destroy();
            }
            
            // Calculate y-axis range for better separation
            let minPrice = 999999;
            let maxPrice = 0;
            datasets.forEach(dataset => {
                dataset.data.forEach(val => {
                    if (val !== null && val !== undefined) {
                        minPrice = Math.min(minPrice, val);
                        maxPrice = Math.max(maxPrice, val);
                    }
                });
            });
            
            // Add padding to y-axis
            const yPadding = (maxPrice - minPrice) * 0.15;
            
            priceTrendsChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels.map(d => dayjs(d).format('MMM D')),
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'index',
                        intersect: false,
                    },
                    plugins: {
                        legend: {
                            position: 'bottom',
                            labels: {
                                usePointStyle: true,
                                padding: 15,
                                font: {
                                    size: 11
                                }
                            }
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            backgroundColor: 'rgba(0, 0, 0, 0.9)',
                            titleColor: '#fff',
                            bodyColor: '#fff',
                            borderColor: '#333',
                            borderWidth: 1,
                            padding: 12,
                            displayColors: true,
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    if (context.parsed.y !== null) {
                                        label += '$' + Math.round(context.parsed.y);
                                    }
                                    return label;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            grid: {
                                display: false
                            },
                            ticks: {
                                autoSkip: false,
                                maxRotation: 45,
                                minRotation: 45,
                                font: {
                                    size: 10
                                }
                            }
                        },
                        y: {
                            min: Math.max(0, minPrice - yPadding),
                            max: maxPrice + yPadding,
                            grid: {
                                color: 'rgba(0, 0, 0, 0.05)'
                            },
                            ticks: {
                                callback: function(value) {
                                    return '$' + Math.round(value);
                                },
                                font: {
                                    size: 11
                                }
                            }
                        }
                    }
                }
            });
        }

        // Pricing Optimization Calculation Functions
        function calculateOptimizedTarget(medianPrice, avgPerformance) {
            if (!avgPerformance || !medianPrice || medianPrice <= 0) return null;
            return medianPrice * (1 + (avgPerformance / 100));
        }

        function calculatePriceAdjustment(currentPrice, targetPrice) {
            if (!currentPrice || !targetPrice || currentPrice <= 0) return null;
            return ((targetPrice - currentPrice) / currentPrice) * 100;
        }

        function getAdjustmentCategory(adjustmentPercent) {
            if (adjustmentPercent === null || adjustmentPercent === undefined) return "no-data";
            if (adjustmentPercent > 10) return "increase-significant";
            if (adjustmentPercent > 2) return "increase-moderate"; 
            if (adjustmentPercent < -10) return "decrease-significant";
            if (adjustmentPercent < -2) return "decrease-moderate";
            return "optimal";
        }

        function formatAdjustmentText(adjustmentPercent) {
            if (adjustmentPercent === null || adjustmentPercent === undefined) return "N/A";
            const absPercent = Math.abs(adjustmentPercent);
            const action = adjustmentPercent > 0 ? "Increase" : "Decrease";
            return `${action} ${absPercent.toFixed(1)}%`;
        }

        function updatePricingTable() {
            const tbody = document.getElementById('pricing-table-body');
            tbody.innerHTML = '';
            
            if (!pricingData || !pricingData[0] || !pricingData[0].data) {
                tbody.innerHTML = '<tr><td colspan="17">No pricing data available</td></tr>';
                return;
            }
            
            const priceData = pricingData[0].data.slice(0, 90);  // Get first 90 days
            const filterValue = document.getElementById('availability-filter').value;
            
            // Calculate gap nights for each day
            function calculateGapNights(index) {
                const currentDay = priceData[index];
                
                // Only calculate for available days
                if (currentDay.demand_desc === 'Unavailable') return 0;
                
                // Count total unavailable days in dataset
                const totalUnavailableDays = priceData.filter(day => day.demand_desc === 'Unavailable').length;
                if (totalUnavailableDays === 0) return 'N/A';
                
                // Find previous unavailable day
                let prevUnavailableIndex = -1;
                for (let i = index - 1; i >= 0; i--) {
                    if (priceData[i].demand_desc === 'Unavailable') {
                        prevUnavailableIndex = i;
                        break;
                    }
                }
                
                // Find next unavailable day
                let nextUnavailableIndex = -1;
                for (let i = index + 1; i < priceData.length; i++) {
                    if (priceData[i].demand_desc === 'Unavailable') {
                        nextUnavailableIndex = i;
                        break;
                    }
                }
                
                // Must have bookings on both sides to be a gap
                if (prevUnavailableIndex === -1 || nextUnavailableIndex === -1) {
                    return 'N/A'; // Not a gap, just continuous availability
                }
                
                // Count consecutive available days between the bookings
                return nextUnavailableIndex - prevUnavailableIndex - 1;
            }
            
            // Get percentile data if available
            let percentileData = null;
            let occupancyData = null;
            if (neighborhoodData && neighborhoodData.data) {
                const futurePercentiles = neighborhoodData.data['Future Percentile Prices'];
                const futureOccupancy = neighborhoodData.data['Future Occ/New/Canc'];
                const bedroomCount = listingData.listing_data.no_of_bedrooms || 1;
                
                if (futurePercentiles && futurePercentiles.Category) {
                    percentileData = futurePercentiles.Category[bedroomCount] || futurePercentiles.Category['1'];
                }
                
                if (futureOccupancy && futureOccupancy.Category) {
                    occupancyData = futureOccupancy.Category[bedroomCount] || futureOccupancy.Category['1'];
                }
            }
            
            // First pass: collect gap information for border grouping
            const gapInfo = [];
            const visibleRows = [];
            
            priceData.forEach((day, index) => {
                // Skip unavailable days if filter is set to 'available'
                if (filterValue === 'available' && day.demand_desc === 'Unavailable') {
                    return;
                }
                
                const gapNights = calculateGapNights(index);
                visibleRows.push({
                    day,
                    index,
                    gapNights
                });
            });
            
            // Second pass: determine gap group positions
            let currentGapId = null;
            let gapGroupStart = -1;
            
            visibleRows.forEach((rowData, visibleIndex) => {
                const { day, index, gapNights } = rowData;
                
                if (gapNights !== 'N/A' && gapNights !== 0) {
                    if (currentGapId !== gapNights || visibleIndex - 1 !== gapGroupStart + (visibleIndex - gapGroupStart - 1)) {
                        // New gap group
                        currentGapId = gapNights;
                        gapGroupStart = visibleIndex;
                    }
                } else {
                    currentGapId = null;
                    gapGroupStart = -1;
                }
                
                gapInfo.push({
                    hasGap: gapNights !== 'N/A' && gapNights !== 0,
                    gapValue: gapNights,
                    gapId: currentGapId
                });
            });
            
            // Third pass: render rows with gap border classes
            visibleRows.forEach((rowData, visibleIndex) => {
                const { day, index, gapNights } = rowData;
                
                const row = document.createElement('tr');
                
                const date = dayjs(day.date);
                const dayOfWeek = date.format('ddd');
                const isWeekend = dayOfWeek === 'Sat' || dayOfWeek === 'Sun';
                
                if (isWeekend) {
                    row.className = 'weekend';
                }
                
                // Get percentiles for this date
                let p25 = '-', p50 = '-', p75 = '-', pMedian = '-', p90 = '-';
                if (percentileData && percentileData.Y_values && percentileData.X_values) {
                    const dateIndex = percentileData.X_values.indexOf(day.date);
                    if (dateIndex !== -1) {
                        p25 = '$' + Math.round(percentileData.Y_values[0][dateIndex]);
                        p50 = '$' + Math.round(percentileData.Y_values[1][dateIndex]);
                        p75 = '$' + Math.round(percentileData.Y_values[2][dateIndex]);
                        pMedian = '$' + Math.round(percentileData.Y_values[3][dateIndex]);
                        p90 = '$' + Math.round(percentileData.Y_values[4][dateIndex]);
                    }
                }
                
                // Get occupancy data for this date
                let marketOcc = '-', marketOccLY = '-', marketOccSTLY = '-';
                if (occupancyData && occupancyData.Y_values && occupancyData.X_values) {
                    const occDateIndex = occupancyData.X_values.indexOf(day.date);
                    if (occDateIndex !== -1) {
                        // Y_values[0] = Occupancy, Y_values[3] = Occupancy_LY, Y_values[4] = Occupancy_STLY
                        const occ = occupancyData.Y_values[0] && occupancyData.Y_values[0][0] ? 
                            occupancyData.Y_values[0][0][occDateIndex] : null;
                        const occLY = occupancyData.Y_values[3] && occupancyData.Y_values[3][0] ? 
                            occupancyData.Y_values[3][0][occDateIndex] : null;
                        const occSTLY = occupancyData.Y_values[4] && occupancyData.Y_values[4][0] ? 
                            occupancyData.Y_values[4][0][occDateIndex] : null;
                        
                        if (occ !== null && occ !== undefined) marketOcc = Math.round(occ) + '%';
                        if (occLY !== null && occLY !== undefined) marketOccLY = Math.round(occLY) + '%';
                        if (occSTLY !== null && occSTLY !== undefined) marketOccSTLY = Math.round(occSTLY) + '%';
                    }
                }
                
                // Determine demand class
                let demandClass = 'demand-unavailable';
                let demandText = day.demand_desc || 'Unknown';
                if (demandText.includes('Low')) demandClass = 'demand-low';
                else if (demandText.includes('Medium')) demandClass = 'demand-medium';
                else if (demandText.includes('High')) demandClass = 'demand-high';
                
                // Add gap border styling
                const currentGapInfo = gapInfo[visibleIndex];
                if (currentGapInfo && currentGapInfo.hasGap) {
                    const prevGapInfo = visibleIndex > 0 ? gapInfo[visibleIndex - 1] : null;
                    const nextGapInfo = visibleIndex < gapInfo.length - 1 ? gapInfo[visibleIndex + 1] : null;
                    
                    const isFirstInGap = !prevGapInfo || !prevGapInfo.hasGap || prevGapInfo.gapId !== currentGapInfo.gapId;
                    const isLastInGap = !nextGapInfo || !nextGapInfo.hasGap || nextGapInfo.gapId !== currentGapInfo.gapId;
                    
                    if (isFirstInGap && isLastInGap) {
                        row.classList.add('gap-single');
                    } else if (isFirstInGap) {
                        row.classList.add('gap-first');
                    } else if (isLastInGap) {
                        row.classList.add('gap-last');
                    } else {
                        row.classList.add('gap-middle');
                    }
                }
                
                // Calculate optimization data
                let optimizedTarget = null;
                let adjustmentPercent = null;
                let adjustmentText = "N/A";
                let adjustmentClass = "no-data";
                let avgPercentText = "N/A";
                let avgPercentClass = "";

                // Log for first row only to avoid spam
                if (visibleIndex === 0) {
                    console.group('💰 DEBUG: Pricing Column Calculation (first row)');
                    console.log('1. bookedDaysInsights:', bookedDaysInsights);
                    console.log('2. isDataAvailable:', bookedDaysInsights.isDataAvailable);
                    console.log('3. pMedian:', pMedian);
                    console.log('4. day.price:', day.price);
                }

                if (bookedDaysInsights.isDataAvailable && pMedian !== '-') {
                    const medianPrice = parseFloat(pMedian.replace('$', ''));
                    optimizedTarget = calculateOptimizedTarget(medianPrice, bookedDaysInsights.avgPercentVsMarket);

                    if (visibleIndex === 0) {
                        console.log('5. medianPrice:', medianPrice);
                        console.log('6. optimizedTarget (Top End):', optimizedTarget);
                    }

                    if (optimizedTarget && day.price) {
                        // Calculate difference from top end (positive = above top end, negative = below)
                        const dollarDifference = day.price - optimizedTarget;
                        adjustmentPercent = (dollarDifference / optimizedTarget) * 100;

                        // Format the text to show vs Top End
                        if (dollarDifference > 0) {
                            adjustmentText = `+$${Math.round(Math.abs(dollarDifference))} (${Math.abs(adjustmentPercent).toFixed(0)}% above)`;
                        } else {
                            adjustmentText = `-$${Math.round(Math.abs(dollarDifference))} (${Math.abs(adjustmentPercent).toFixed(0)}% below)`;
                        }

                        // Color coding: Red/Orange = above top end (risky), Yellow/Green/Blue = below (safe)
                        if (adjustmentPercent > 10) {
                            adjustmentClass = 'above-top-end-high';  // Red - danger zone
                        } else if (adjustmentPercent > 0) {
                            adjustmentClass = 'above-top-end-low';   // Orange - warning
                        } else if (adjustmentPercent > -20) {
                            adjustmentClass = 'below-top-end-close'; // Yellow - close to ceiling
                        } else if (adjustmentPercent > -40) {
                            adjustmentClass = 'below-top-end-good';  // Green - good gap pricing
                        } else {
                            adjustmentClass = 'below-top-end-aggressive'; // Blue - very competitive
                        }

                        if (visibleIndex === 0) {
                            console.log('7. dollarDifference:', dollarDifference);
                            console.log('8. adjustmentText:', adjustmentText);
                            console.log('9. adjustmentClass:', adjustmentClass);
                        }
                    }

                    avgPercentText = `${bookedDaysInsights.avgPercentVsMarket >= 0 ? '+' : ''}${bookedDaysInsights.avgPercentVsMarket.toFixed(1)}%`;
                    avgPercentClass = bookedDaysInsights.avgPercentVsMarket >= 0 ? 'positive' : 'negative';

                    if (visibleIndex === 0) {
                        console.log('10. avgPercentText:', avgPercentText);
                        console.log('11. avgPercentClass:', avgPercentClass);
                        console.groupEnd();
                    }
                } else {
                    if (visibleIndex === 0) {
                        console.log('❌ Skipping calculation - conditions not met');
                        console.groupEnd();
                    }
                }

                // Calculate booking window risk
                const riskData = calculateBookingWindowRisk(day.date, day.demand_desc);
                const bookingWindowCell = formatBookingWindowDisplay(riskData);

                row.innerHTML = `
                    <td class="date-cell">${date.format('MMM D')}</td>
                    <td>${dayOfWeek}</td>
                    <td><span class="our-price">$${day.price}</span></td>
                    <td>${pMedian}</td>
                    <td class="our-avg-vs-market ${avgPercentClass}">${avgPercentText}</td>
                    <td class="optimized-target">${optimizedTarget ? '$' + Math.round(optimizedTarget) : 'N/A'}</td>
                    <td class="price-adjustment ${adjustmentClass}">${adjustmentText}</td>
                    <td class="booking-window-cell">${bookingWindowCell}</td>
                    <td>${day.min_stay || 1}</td>
                    <td>${gapNights}</td>
                    <td>${marketOcc}</td>
                    <td>${marketOccLY}</td>
                    <td>${marketOccSTLY}</td>
                    <td>${p25}</td>
                    <td>${p50}</td>
                    <td>${p75}</td>
                    <td>${p90}</td>
                    <td><span class="demand-badge ${demandClass}">${demandText}</span></td>
                `;

                tbody.appendChild(row);
            });

            // Initialize tooltip portals for newly rendered badges
            initializeTooltipPortals();
        }

        // ============= BOOKING WINDOW RISK FUNCTIONS =============

        /**
         * Builds a monthly booking window lookup table from Market KPI data
         * @param {Object} neighborData - The neighborhood API response
         * @param {number} bedroomCount - Number of bedrooms for the property
         * @returns {Object} Monthly lookup table {Jan: 25, Feb: 28, ...}
         */
        function buildBookingWindowLookup(neighborData, bedroomCount = 5) {
            const lookup = {};

            if (!neighborData || !neighborData.data || !neighborData.data['Market KPI'] || !neighborData.data['Market KPI'].Category) {
                console.error('[buildBookingWindowLookup] Invalid neighborhood data structure');
                return lookup;
            }

            const marketKPI = neighborData.data['Market KPI'];
            let categoryData = marketKPI.Category[bedroomCount.toString()];

            if (!categoryData && marketKPI.Category['-1']) {
                console.log('[buildBookingWindowLookup] Using fallback category -1 (all bedrooms)');
                categoryData = marketKPI.Category['-1'];
            }

            if (!categoryData || !categoryData.X_values || !categoryData.Y_values || !categoryData.Y_values[1]) {
                console.error('[buildBookingWindowLookup] Missing required data');
                return lookup;
            }

            const xValues = categoryData.X_values;
            const bookingWindows = categoryData.Y_values[1]; // Index 1 = Booking Window
            const monthGroups = {};

            for (let i = 0; i < xValues.length; i++) {
                const period = xValues[i];
                const window = bookingWindows[i];

                if (period.includes('Last') || period.includes('Days')) continue;
                if (window === null || window === undefined || window <= 0) continue;

                const monthMatch = period.match(/^([A-Z][a-z]{2})/);
                if (!monthMatch) continue;

                const month = monthMatch[1];
                if (!monthGroups[month]) monthGroups[month] = [];
                monthGroups[month].push(window);
            }

            for (const month in monthGroups) {
                const values = monthGroups[month];
                const average = values.reduce((sum, val) => sum + val, 0) / values.length;
                lookup[month] = Math.round(average);
            }

            const allMonths = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            const existingValues = Object.values(lookup);

            if (existingValues.length > 0) {
                const overallAverage = Math.round(existingValues.reduce((sum, val) => sum + val, 0) / existingValues.length);
                for (const month of allMonths) {
                    if (!lookup[month]) lookup[month] = overallAverage;
                }
            }

            console.log('[buildBookingWindowLookup] Created lookup:', lookup);
            return lookup;
        }

        /**
         * Calculates booking window risk for a specific check-in date
         * INCLUDES CRITICAL UTC DATE FIX for accurate day calculations
         * @param {string} checkInDate - Check-in date in YYYY-MM-DD format
         * @param {string} bookingStatus - Booking status ("Booked" or "")
         * @param {Date} todayDate - Current date (for testing purposes)
         * @returns {Object|null} Risk data object or null for booked/past dates
         */
        function calculateBookingWindowRisk(checkInDate, bookingStatus, todayDate = new Date()) {
            if (bookingStatus === "Booked" || bookingStatus === "booked" || bookingStatus === "Unavailable") return null;

            const checkIn = new Date(checkInDate);
            if (isNaN(checkIn.getTime())) return null;

            const today = new Date(todayDate);
            today.setHours(0, 0, 0, 0);

            const checkInOnly = new Date(checkIn);
            checkInOnly.setHours(0, 0, 0, 0);

            if (checkInOnly <= today) return null;

            const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            const monthName = monthNames[checkIn.getMonth()];
            const bookingWindow = bookingWindowLookup[monthName];

            if (!bookingWindow || bookingWindow <= 0) return null;

            const riskThresholdDate = new Date(checkIn);
            riskThresholdDate.setDate(riskThresholdDate.getDate() - bookingWindow);

            // CRITICAL FIX: UTC-based day calculation to avoid timezone issues
            function daysBetween(date1, date2) {
                const utc1 = Date.UTC(date1.getFullYear(), date1.getMonth(), date1.getDate());
                const utc2 = Date.UTC(date2.getFullYear(), date2.getMonth(), date2.getDate());
                return Math.floor((utc2 - utc1) / (24 * 60 * 60 * 1000));
            }

            const daysUntilWindow = daysBetween(today, riskThresholdDate);

            let riskLevel, icon, displayText, colorClass;

            if (daysUntilWindow > 7) {
                riskLevel = 'safe';
                icon = '✅';
                displayText = `${icon} Opens in ${daysUntilWindow} ${daysUntilWindow === 1 ? 'day' : 'days'}`;
                colorClass = 'risk-safe';
            } else if (daysUntilWindow >= 0) {
                riskLevel = 'watch';
                icon = '⚠️';
                displayText = daysUntilWindow === 0 ? `${icon} Opens today` : `${icon} Opens in ${daysUntilWindow} ${daysUntilWindow === 1 ? 'day' : 'days'}`;
                colorClass = 'risk-watch';
            } else if (daysUntilWindow >= -7) {
                riskLevel = 'risk';
                icon = '🚨';
                const daysPast = Math.abs(daysUntilWindow);
                displayText = `${icon} ${daysPast} ${daysPast === 1 ? 'day' : 'days'} overdue`;
                colorClass = 'risk-risk';
            } else {
                riskLevel = 'high';
                icon = '🔴';
                const daysPast = Math.abs(daysUntilWindow);
                displayText = `${icon} ${daysPast} days OVERDUE`;
                colorClass = 'risk-high';
            }

            return {
                bookingWindow,
                riskThresholdDate: riskThresholdDate.toISOString().split('T')[0],
                daysUntilWindow,
                riskLevel,
                displayText,
                colorClass,
                checkInDate,
                monthName
            };
        }

        /**
         * Formats risk data for table display with tooltip
         * @param {Object|null} riskData - Risk data from calculateBookingWindowRisk()
         * @returns {string} HTML string for table cell
         */
        function formatBookingWindowDisplay(riskData) {
            if (!riskData) {
                return '<span class="booking-window-status risk-booked">—</span>';
            }

            const { displayText, colorClass, bookingWindow, riskThresholdDate, daysUntilWindow, monthName } = riskData;
            const thresholdDate = new Date(riskThresholdDate);
            const thresholdFormatted = thresholdDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
            const tense = daysUntilWindow >= 0 ? 'opens' : 'opened';

            return `
                <span class="booking-window-status ${colorClass}">
                    ${displayText}
                    <div class="booking-window-tooltip">
                        <strong>Booking Window Details</strong>
                        <hr>
                        <div class="tooltip-row">
                            <span class="tooltip-label">Month:</span>
                            <span class="tooltip-value">${monthName}</span>
                        </div>
                        <div class="tooltip-row">
                            <span class="tooltip-label">Typical window:</span>
                            <span class="tooltip-value">${bookingWindow} days</span>
                        </div>
                        <div class="tooltip-row">
                            <span class="tooltip-label">Window ${tense}:</span>
                            <span class="tooltip-value">${thresholdFormatted}</span>
                        </div>
                        <div class="tooltip-info">
                            <em>Market books ${monthName} dates ~${bookingWindow} days ahead</em>
                        </div>
                    </div>
                </span>
            `;
        }

        // ============= TOOLTIP PORTAL SYSTEM =============

        /**
         * Creates global tooltip portal container in DOM if it doesn't exist
         * Called once on DOMContentLoaded
         */
        function createTooltipPortal() {
            if (document.getElementById('global-tooltip-portal')) {
                return; // Already exists
            }

            const portal = document.createElement('div');
            portal.id = 'global-tooltip-portal';
            portal.className = 'tooltip-portal-container';
            document.body.appendChild(portal);

            console.log('[Tooltip Portal] Global container created');
        }

        /**
         * Initializes tooltip event listeners for all booking window badges
         * Called after table is rendered/updated
         */
        function initializeTooltipPortals() {
            // Find all booking window status badges that have tooltips
            const badges = document.querySelectorAll('.booking-window-status');

            console.log(`[Tooltip Portal] Initializing ${badges.length} tooltip badges`);

            badges.forEach(badge => {
                const tooltip = badge.querySelector('.booking-window-tooltip');
                if (!tooltip) return;

                // Store reference to original parent for cleanup
                if (!tooltip.dataset.initialized) {
                    tooltip._originalParent = badge;
                    tooltip.dataset.initialized = 'true';

                    // Add event listeners to badge
                    badge.addEventListener('mouseenter', handleBadgeHover);
                    badge.addEventListener('mouseleave', handleBadgeLeave);
                }
            });
        }

        /**
         * Handles mouseenter on booking window badge
         * Portals the tooltip to global container and positions it
         */
        function handleBadgeHover(event) {
            const badge = event.currentTarget;
            const tooltip = badge.querySelector('.booking-window-tooltip');

            if (!tooltip) return;

            // Clear any pending cleanup
            if (tooltipCleanupTimer) {
                clearTimeout(tooltipCleanupTimer);
                tooltipCleanupTimer = null;
            }

            // Hide any currently active tooltip
            if (activeTooltip && activeTooltip !== tooltip) {
                hideTooltip(activeTooltip);
            }

            // Show this tooltip
            showTooltipInPortal(badge, tooltip);
            activeTooltip = tooltip;
        }

        /**
         * Handles mouseleave on booking window badge
         * Hides tooltip with delay to allow moving to tooltip
         */
        function handleBadgeLeave(event) {
            const badge = event.currentTarget;
            const tooltip = badge.querySelector('.booking-window-tooltip');

            if (!tooltip) return;

            // Delay hiding to allow user to move mouse to tooltip
            tooltipCleanupTimer = setTimeout(() => {
                hideTooltip(tooltip);
                if (activeTooltip === tooltip) {
                    activeTooltip = null;
                }
            }, 100); // 100ms grace period
        }

        /**
         * Shows tooltip in global portal with fixed positioning
         * @param {HTMLElement} badge - The badge element being hovered
         * @param {HTMLElement} tooltip - The tooltip to show
         */
        function showTooltipInPortal(badge, tooltip) {
            const portal = document.getElementById('global-tooltip-portal');
            if (!portal) {
                console.error('[Tooltip Portal] Global container not found!');
                return;
            }

            // Get badge position relative to viewport
            const badgeRect = badge.getBoundingClientRect();

            // Calculate tooltip position
            const left = badgeRect.left + (badgeRect.width / 2);
            const top = badgeRect.bottom + 4; // 4px gap (matches CSS)

            // Move tooltip to portal
            portal.appendChild(tooltip);

            // Apply fixed positioning
            tooltip.style.position = 'fixed';
            tooltip.style.top = top + 'px';
            tooltip.style.left = left + 'px';
            tooltip.style.transform = 'translateX(-50%)'; // Center horizontally
            tooltip.style.zIndex = '99999';

            // Make visible (trigger CSS transition)
            requestAnimationFrame(() => {
                tooltip.style.opacity = '1';
                tooltip.style.pointerEvents = 'auto';
            });

            console.log('[Tooltip Portal] Tooltip shown at', { left, top });
        }

        /**
         * Hides tooltip and returns it to original parent
         * @param {HTMLElement} tooltip - The tooltip to hide
         */
        function hideTooltip(tooltip) {
            if (!tooltip) return;

            // Fade out
            tooltip.style.opacity = '0';
            tooltip.style.pointerEvents = 'none';

            // Wait for CSS transition (200ms) then return to parent
            setTimeout(() => {
                const originalParent = tooltip._originalParent;

                if (originalParent && tooltip.style.opacity === '0') {
                    // Return to original parent
                    originalParent.appendChild(tooltip);

                    // Reset to CSS-controlled positioning
                    tooltip.style.position = '';
                    tooltip.style.top = '';
                    tooltip.style.left = '';
                    tooltip.style.transform = '';
                    tooltip.style.zIndex = '';

                    console.log('[Tooltip Portal] Tooltip returned to original parent');
                }
            }, 200); // Match CSS transition duration
        }

        /**
         * Cleanup function to remove all tooltip event listeners
         * Useful for testing/debugging
         */
        function cleanupTooltipPortals() {
            const badges = document.querySelectorAll('.booking-window-status');
            badges.forEach(badge => {
                badge.removeEventListener('mouseenter', handleBadgeHover);
                badge.removeEventListener('mouseleave', handleBadgeLeave);
            });

            if (activeTooltip) {
                hideTooltip(activeTooltip);
                activeTooltip = null;
            }

            console.log('[Tooltip Portal] Cleaned up all tooltip listeners');
        }

        // ============= BOOKED DAYS COMPONENT FUNCTIONS =============

        async function loadBookedDaysComponent(reservationData) {
            try {
                // Process the reservation data for booked days analysis
                const comparisonData = processBookedDaysData(reservationData);
                
                if (comparisonData.length > 0) {
                    // Show the component
                    document.getElementById('booked-days-section').style.display = 'block';
                    
                    // Update summary stats
                    updateBookedDaysSummary(comparisonData);
                    
                    // Update property info
                    const bedroomCount = listingData.listing_data.no_of_bedrooms || 1;
                    document.getElementById('booked-days-property-info').textContent = 
                        `${listingData.listing_data.name || 'Property'} (${bedroomCount} bed)`;
                    
                    // Render the table
                    renderBookedDaysTable(comparisonData);
                    
                    // Refresh pricing table with optimization data now that insights are available
                    updatePricingTable();
                }
            } catch (error) {
                console.error('Error loading booked days component:', error);
            }
        }

        function processBookedDaysData(reservationData) {
            console.group('🔍 DEBUG: processBookedDaysData');
            console.log('1. Reservation Data:', reservationData);

            if (!reservationData || !reservationData.data || reservationData.data.length === 0) {
                console.warn('❌ No reservation data available');
                console.groupEnd();
                return [];
            }

            console.log('2. Total reservation records:', reservationData.data.length);
            console.log('3. Listing ID from listingData:', listingData.listing_data?.id);

            // Filter for valid bookings with revenue
            const validBookings = reservationData.data.filter(booking => {
                const statusOk = booking.booking_status === 'booked';
                const revenueOk = parseFloat(booking.rental_revenue) > 0;
                const idMatch = String(booking.listing_id) === String(listingData.listing_data.id);

                console.log(`   Booking ${booking.reservation_id}:`, {
                    booking_listing_id: String(booking.listing_id),
                    target_listing_id: String(listingData.listing_data.id),
                    listing_id: booking.listing_id,
                    status: booking.booking_status,
                    statusOk,
                    revenue: booking.rental_revenue,
                    revenueOk,
                    idMatch,
                    passes: statusOk && revenueOk && idMatch
                });

                return statusOk && revenueOk && idMatch;
            });

            console.log('4. Valid bookings after filtering:', validBookings.length);

            if (validBookings.length === 0) {
                console.warn('❌ No valid bookings found after filtering');
                console.groupEnd();
                return [];
            }

            console.log('✅ Valid bookings:', validBookings);

            // Get median booked price data from neighborhood data
            const bedroomCount = listingData.listing_data.no_of_bedrooms || 1;
            let medianPriceData = null;
            
            if (neighborhoodData && neighborhoodData.data && neighborhoodData.data['Future Percentile Prices']) {
                const futurePercentiles = neighborhoodData.data['Future Percentile Prices'];
                if (futurePercentiles.Category) {
                    medianPriceData = futurePercentiles.Category[bedroomCount] || futurePercentiles.Category['1'];
                }
            }

            // Process bookings and create comparison data
            const comparisonData = [];

            console.log('6. Processing bookings for comparison data...');
            console.log('   Bedroom count:', bedroomCount);
            console.log('   medianPriceData available:', !!medianPriceData);
            if (medianPriceData && medianPriceData.X_values) {
                console.log('   Date range in market data:', medianPriceData.X_values[0], 'to', medianPriceData.X_values[medianPriceData.X_values.length - 1]);
            }

            validBookings.forEach((booking, idx) => {
                const checkInDate = booking.check_in;
                const nights = parseInt(booking.no_of_days) || 1;
                const nightlyRate = parseFloat(booking.rental_revenue) / nights;

                console.log(`\n   Processing booking ${idx + 1}:`, {
                    checkInDate,
                    nights,
                    nightlyRate,
                    totalRevenue: booking.rental_revenue
                });

                // Calculate average market median across all nights of the booking
                let marketMedian = null;

                if (medianPriceData && medianPriceData.X_values && medianPriceData.Y_values) {
                    let totalMarketMedian = 0;
                    let validDays = 0;

                    // Loop through each night of the booking
                    for (let i = 0; i < nights; i++) {
                        const currentDate = dayjs(checkInDate).add(i, 'day').format('YYYY-MM-DD');
                        const dateIndex = medianPriceData.X_values.indexOf(currentDate);

                        console.log(`     Night ${i + 1}: ${currentDate}, index: ${dateIndex}`);

                        if (dateIndex !== -1 && medianPriceData.Y_values[3] && medianPriceData.Y_values[3][dateIndex]) {
                            totalMarketMedian += medianPriceData.Y_values[3][dateIndex]; // Index 3 is median booked price
                            validDays++;
                            console.log(`       ✅ Found market median: $${medianPriceData.Y_values[3][dateIndex]}`);
                        } else {
                            console.log(`       ❌ No market data for this date`);
                        }
                    }

                    // Calculate average market median if we have data for at least one day
                    if (validDays > 0) {
                        marketMedian = totalMarketMedian / validDays;
                        console.log(`     Average market median: $${marketMedian.toFixed(2)} (${validDays} days)`);
                    } else {
                        console.log(`     ❌ No valid days found in market data`);
                    }
                } else {
                    console.log('     ❌ No median price data structure available');
                }

                if (marketMedian && marketMedian > 0) {
                    const checkOutDate = dayjs(checkInDate).add(nights, 'day').format('YYYY-MM-DD');
                    const percentageVsMarket = ((nightlyRate - marketMedian) / marketMedian) * 100;
                    const difference = nightlyRate - marketMedian;

                    const comparisonEntry = {
                        checkIn: checkInDate,
                        checkOut: checkOutDate,
                        nights: nights,
                        totalRevenue: parseFloat(booking.rental_revenue),
                        dailyRate: nightlyRate,
                        marketMedian: marketMedian,
                        difference: difference,
                        percentageVsMarket: percentageVsMarket,
                        bookingId: booking.reservation_id
                    };

                    comparisonData.push(comparisonEntry);
                    console.log(`     ✅ Added to comparison data:`, comparisonEntry);
                } else {
                    console.log(`     ❌ Skipped - no valid market median (marketMedian: ${marketMedian})`);
                }
            });

            // Sort by check-in date
            comparisonData.sort((a, b) => new Date(a.checkIn) - new Date(b.checkIn));

            console.log('5. Final comparison data:', comparisonData);
            console.groupEnd();

            return comparisonData;
        }

        function updateBookedDaysSummary(comparisonData) {
            console.group('📊 DEBUG: updateBookedDaysSummary');
            console.log('1. Comparison data:', comparisonData);

            const totalBookings = comparisonData.length;
            console.log('2. Total bookings:', totalBookings);
            const totalRevenue = comparisonData.reduce((sum, booking) => sum + booking.totalRevenue, 0);
            const avgDailyRevenue = totalRevenue / comparisonData.reduce((sum, booking) => sum + booking.nights, 0);
            const avgMarketMedian = comparisonData.reduce((sum, booking) => sum + booking.marketMedian, 0) / totalBookings;

            // Calculate average percentage vs market
            const avgPercentVsMarket = comparisonData.reduce((sum, booking) => sum + booking.percentageVsMarket, 0) / totalBookings;
            console.log('3. Average percentage vs market:', avgPercentVsMarket);

            // Store insights globally for pricing optimization
            bookedDaysInsights = {
                avgPercentVsMarket: avgPercentVsMarket,
                totalBookings: totalBookings,
                isDataAvailable: true,
                lastCalculated: new Date().toISOString()
            };
            console.log('4. bookedDaysInsights object created:', bookedDaysInsights);
            console.groupEnd();

            document.getElementById('total-booked-days').textContent =
                comparisonData.reduce((sum, booking) => sum + booking.nights, 0);
            document.getElementById('avg-daily-revenue').textContent = `$${Math.round(avgDailyRevenue)}`;
            document.getElementById('vs-market-median').textContent = `$${Math.round(avgMarketMedian)}`;
            document.getElementById('total-revenue').textContent = `$${Math.round(totalRevenue)}`;

            // Update the new average percentage stat with color coding
            const avgPercentElement = document.getElementById('avg-percent-vs-market');
            const percentText = `${avgPercentVsMarket >= 0 ? '+' : ''}${avgPercentVsMarket.toFixed(1)}%`;
            avgPercentElement.textContent = percentText;

            // Add color coding based on performance
            avgPercentElement.className = `booked-days-stat-value ${avgPercentVsMarket >= 0 ? 'positive' : 'negative'}`;
        }

        function renderBookedDaysTable(comparisonData) {
            const tbody = document.getElementById('booked-days-table-body');
            tbody.innerHTML = '';
            
            if (comparisonData.length === 0) {
                const row = document.createElement('tr');
                row.innerHTML = '<td colspan="8" style="text-align: center; color: #666; padding: 20px;">No booked days data available</td>';
                tbody.appendChild(row);
                return;
            }

            comparisonData.forEach(booking => {
                const row = document.createElement('tr');
                
                const checkInDate = dayjs(booking.checkIn);
                const checkOutDate = dayjs(booking.checkOut);
                const dayOfWeek = checkInDate.format('ddd');
                const isWeekend = dayOfWeek === 'Sat' || dayOfWeek === 'Sun';
                
                if (isWeekend) {
                    row.className = 'weekend';
                }
                
                // Determine performance indicator
                let perfClass = '';
                let perfText = '';
                if (booking.percentageVsMarket > 5) {
                    perfClass = 'above-median';
                    perfText = `+${booking.percentageVsMarket.toFixed(1)}%`;
                } else if (booking.percentageVsMarket < -5) {
                    perfClass = 'below-median';
                    perfText = `${booking.percentageVsMarket.toFixed(1)}%`;
                } else {
                    perfClass = 'at-median';
                    perfText = `${booking.percentageVsMarket.toFixed(1)}%`;
                }
                
                row.innerHTML = `
                    <td>${checkInDate.format('MMM D')}</td>
                    <td>${checkOutDate.format('MMM D')}</td>
                    <td>${booking.nights}</td>
                    <td>$${booking.totalRevenue.toFixed(0)}</td>
                    <td class="our-rate">$${Math.round(booking.dailyRate)}</td>
                    <td>$${Math.round(booking.marketMedian)}</td>
                    <td class="${booking.difference >= 0 ? 'positive' : 'negative'}">
                        ${booking.difference >= 0 ? '+' : ''}$${booking.difference.toFixed(0)}
                    </td>
                    <td><span class="perf-badge ${perfClass}">${perfText}</span></td>
                `;
                
                tbody.appendChild(row);
            });
        }

        function filterBookedDays() {
            const filterValue = document.getElementById('booked-days-filter').value;
            const rows = document.querySelectorAll('#booked-days-table-body tr');
            
            rows.forEach(row => {
                const cells = row.children;
                if (cells.length < 8) return; // Skip header or empty rows
                
                const percentageCell = cells[7]; // Percentage vs median column
                const badge = percentageCell.querySelector('.perf-badge');
                
                if (!badge) return;
                
                const isAbove = badge.classList.contains('above-median');
                const isBelow = badge.classList.contains('below-median');
                
                let shouldShow = true;
                
                switch (filterValue) {
                    case 'above':
                        shouldShow = isAbove;
                        break;
                    case 'below':
                        shouldShow = isBelow;
                        break;
                    default: // 'all'
                        shouldShow = true;
                }
                
                row.style.display = shouldShow ? '' : 'none';
            });
        }
    </script>

    <!-- Global Tooltip Portal Container -->
    <div id="global-tooltip-portal" class="tooltip-portal-container"></div>

</body>
</html>